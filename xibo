#!/usr/bin/env ruby

# Add lib and cli directories to load path
$LOAD_PATH.unshift File.expand_path('lib', __dir__)
$LOAD_PATH.unshift File.expand_path('cli', __dir__)

require 'xibo'  # Load shared library
require 'command_registry'
require 'interactive_menu'

# Option definitions for command-line parsing
OPTION_DEFINITIONS = [
  {
    short: '-f',
    long: '--file FILE',
    description: 'File path (for upload)',
    key: :file
  },
  {
    short: '-n',
    long: '--name NAME',
    description: 'Name (for upload)',
    key: :name
  },
  {
    short: '-i',
    long: '--id ID',
    description: 'Resource ID (for delete/update/show)',
    key: :id
  },
  {
    long: '--folder-id ID',
    description: 'Folder ID',
    key: :folder_id
  },
  {
    long: '--menu-id ID',
    description: 'Menu board ID',
    key: :menu_id
  },
  {
    long: '--category-id ID',
    description: 'Category ID',
    key: :category_id
  },
  {
    long: '--code CODE',
    description: 'Code identifier',
    key: :code
  },
  {
    long: '--description DESC',
    description: 'Description',
    key: :description
  },
  {
    long: '--price AMOUNT',
    description: 'Price (for products)',
    key: :price
  },
  {
    long: '--calories NUM',
    description: 'Calorie count',
    key: :calories,
    processor: ->(val) { val.to_i }
  },
  {
    long: '--allergy-info INFO',
    description: 'Allergy information',
    key: :allergy_info
  },
  {
    long: '--[no-]available',
    description: 'Product availability (default: true)',
    key: :available
  },
  {
    long: '--json',
    description: 'Output in JSON format',
    key: :json,
    flag: true
  },
  {
    long: '--url URL',
    description: 'Image URL (for upload-image)',
    key: :url
  },
  {
    long: '--random',
    description: 'Use random image (for upload-image)',
    key: :random,
    flag: true
  },
  {
    long: '--size SIZE',
    description: 'Image size for random images (default: 800)',
    key: :size,
    processor: ->(val) { val.to_i }
  },
  {
    long: '--category CATEGORY',
    description: 'Category name (for layouts)',
    key: :category
  },
  {
    long: '--show-grid',
    description: 'Show grid visualization',
    key: :show_grid,
    flag: true
  },
  {
    long: '--force',
    description: 'Skip confirmation prompts',
    key: :force,
    flag: true
  },
  {
    short: '-v',
    long: '--verbose',
    description: 'Verbose output',
    key: :verbose,
    flag: true
  },
  {
    short: '-d',
    long: '--debug',
    description: 'Debug output',
    key: :debug,
    flag: true,
    callback: ->(_) { ENV['DEBUG'] = '1' }
  },
  {
    short: '-h',
    long: '--help',
    description: 'Show this help',
    action: ->(parser) { puts parser; exit }
  }
]

def parse_options
  options = {}
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: xibo COMMAND [options]"
    opts.separator ""
    opts.separator "Commands:"

    CommandRegistry.available_commands.each do |cmd|
      category, action = cmd.split(':')
      description = CommandRegistry.command_description(category.to_sym, action.to_sym)
      opts.separator "  #{cmd.ljust(20)} #{description}"
    end

    opts.separator ""
    opts.separator "Options:"

    # Loop through option definitions to build the parser
    OPTION_DEFINITIONS.each do |opt_def|
      # Build the option flags
      flags = [opt_def[:short], opt_def[:long]].compact

      # Add the description
      flags << opt_def[:description]

      # Handle different option types
      if opt_def[:action]
        # Special action (like help)
        opts.on(*flags) { opt_def[:action].call(opts) }
      elsif opt_def[:flag]
        # Boolean flag option
        opts.on(*flags) do |val|
          options[opt_def[:key]] = val
          opt_def[:callback].call(val) if opt_def[:callback]
        end
      else
        # Regular option with value
        opts.on(*flags) do |val|
          processed_val = opt_def[:processor] ? opt_def[:processor].call(val) : val
          options[opt_def[:key]] = processed_val
          opt_def[:callback].call(processed_val) if opt_def[:callback]
        end
      end
    end

    opts.separator ""
    opts.separator "Examples:"
    opts.separator "  xibo media:list                    # List all media"
    opts.separator "  xibo media:upload-image --random -n 'Logo'  # Upload random image"
    opts.separator "  xibo media:upload-image --url 'http://...' -n 'Banner'"
    opts.separator "  xibo menuboard:list                # List all menu boards"
    opts.separator "  xibo menuboard:create -n 'Lunch'   # Create new menu board"
    opts.separator "  xibo product:add --category-id 1 -n 'Coffee' --price 3.50"
  end

  parser.parse!

  # Get the command from remaining args (if provided)
  command = ARGV.shift
  options[:command] = command

  options
end

def main
  options = parse_options

  # Handle interactive mode
  unless options[:command]
    # No command provided - show category menu
    categories = CommandRegistry.categories
    selected_category = InteractiveMenu.select_from_list(
      "Select a category:",
      categories.map(&:to_s)
    )
    options[:command] = selected_category
  end

  command_parts = options[:command].split(':')

  # If only category provided (no action), show action menu
  if command_parts.length == 1
    category = command_parts[0].to_sym
    actions = CommandRegistry.actions_for_category(category)

    if actions.empty?
      puts "Unknown category: #{category}"
      puts "Run 'xibo --help' for available commands"
      exit 1
    end

    # Build descriptions for each action
    descriptions = {}
    actions.each do |action|
      descriptions[action.to_s] = CommandRegistry.command_description(category, action)
    end

    selected_action = InteractiveMenu.select_from_list(
      "Select an action for #{category}:",
      actions.map(&:to_s),
      descriptions: descriptions
    )

    options[:command] = "#{category}:#{selected_action}"
    command_parts = [category.to_s, selected_action]
  end

  if command_parts.length != 2
    puts "Invalid command format. Use 'category:action' (e.g., media:list)"
    exit 1
  end

  category = command_parts[0].to_sym
  action = command_parts[1].to_sym

  command_class = CommandRegistry.get_command(category, action)

  unless command_class
    puts "Unknown command: #{options[:command]}"
    puts "Run 'xibo --help' for available commands"
    exit 1
  end

  begin
    client = Xibo::Client.new
    command = command_class.new(client, options)
    command.execute
  rescue => e
    puts "Error: #{e.message}"
    exit 1
  end
end

main if __FILE__ == $0